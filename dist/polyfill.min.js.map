{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "index.es6.js",
    "node_modules/assert/assert.js",
    "node_modules/inherits/inherits_browser.js",
    "node_modules/process/browser.js",
    "node_modules/util/support/isBufferBrowser.js",
    "node_modules/util/util.js",
    "spec/reference-implementation/lib/byte-length-queuing-strategy.js",
    "spec/reference-implementation/lib/count-queuing-strategy.js",
    "spec/reference-implementation/lib/helpers.js",
    "spec/reference-implementation/lib/queue-with-sizes.js",
    "spec/reference-implementation/lib/readable-stream.js",
    "spec/reference-implementation/lib/transform-stream.js",
    "spec/reference-implementation/lib/utils.js",
    "spec/reference-implementation/lib/writable-stream.js"
  ],
  "names": [],
  "mappings": "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",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "export const\n  { ReadableStream } = require('./spec/reference-implementation/lib/readable-stream'),\n  { WritableStream } = require('./spec/reference-implementation/lib/writable-stream'),\n  ByteLengthQueuingStrategy = require('./spec/reference-implementation/lib/byte-length-queuing-strategy'),\n  CountQueuingStrategy = require('./spec/reference-implementation/lib/count-queuing-strategy'),\n  TransformStream = require('./spec/reference-implementation/lib/transform-stream');\n\nconst interfaces = {\n  ReadableStream,\n  WritableStream,\n  ByteLengthQueuingStrategy,\n  CountQueuingStrategy,\n  TransformStream\n};\n\n// Export\nexport default interfaces;\n\n// Add classes to window\nif ( typeof window !== \"undefined\" )\n  Object.assign( window, interfaces );\n",
    "// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// when used in node, this will actually load the util module we depend on\n// versus loading the builtin util module as happens otherwise\n// this is a bug in node module loading as far as I am concerned\nvar util = require('util/');\n\nvar pSlice = Array.prototype.slice;\nvar hasOwn = Object.prototype.hasOwnProperty;\n\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  }\n  else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = stackStartFunction.name;\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction replacer(key, value) {\n  if (util.isUndefined(value)) {\n    return '' + value;\n  }\n  if (util.isNumber(value) && !isFinite(value)) {\n    return value.toString();\n  }\n  if (util.isFunction(value) || util.isRegExp(value)) {\n    return value.toString();\n  }\n  return value;\n}\n\nfunction truncate(s, n) {\n  if (util.isString(s)) {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\n\nfunction getMessage(self) {\n  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(JSON.stringify(self.expected, replacer), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {\n    if (actual.length != expected.length) return false;\n\n    for (var i = 0; i < actual.length; i++) {\n      if (actual[i] !== expected[i]) return false;\n    }\n\n    return true;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!util.isObject(actual) && !util.isObject(expected)) {\n    return actual == expected;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b) {\n  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b)) {\n    return a === b;\n  }\n  var aIsArgs = isArguments(a),\n      bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b);\n  }\n  var ka = objectKeys(a),\n      kb = objectKeys(b),\n      key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (util.isString(expected)) {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/message) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\nassert.ifError = function(err) { if (err) {throw err;}};\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n",
    "if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n",
    "// shim for using process in browser\n\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\n(function () {\n  try {\n    cachedSetTimeout = setTimeout;\n  } catch (e) {\n    cachedSetTimeout = function () {\n      throw new Error('setTimeout is not defined');\n    }\n  }\n  try {\n    cachedClearTimeout = clearTimeout;\n  } catch (e) {\n    cachedClearTimeout = function () {\n      throw new Error('clearTimeout is not defined');\n    }\n  }\n} ())\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = cachedSetTimeout.call(null, cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    cachedClearTimeout.call(null, timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        cachedSetTimeout.call(null, drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n",
    "module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}",
    "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n",
    "'use strict';\nconst { createDataProperty } = require('./helpers.js');\n\nmodule.exports = class ByteLengthQueuingStrategy {\n  constructor({ highWaterMark }) {\n    createDataProperty(this, 'highWaterMark', highWaterMark);\n  }\n\n  size(chunk) {\n    return chunk.byteLength;\n  }\n};\n",
    "'use strict';\nconst { createDataProperty } = require('./helpers.js');\n\nmodule.exports = class CountQueuingStrategy {\n  constructor({ highWaterMark }) {\n    createDataProperty(this, 'highWaterMark', highWaterMark);\n  }\n\n  size(chunk) {\n    return 1;\n  }\n};\n",
    "'use strict';\nconst assert = require('assert');\n\nexports.promiseCall = (func, ...args) => {\n  try {\n    return Promise.resolve(func(...args));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nexports.typeIsObject = x => (typeof x === 'object' && x !== null) || typeof x === 'function';\n\nexports.toInteger = v => {\n  v = Number(v);\n  if (isNaN(v)) {\n    return 0;\n  }\n\n  if (v < 0) {\n    return -1 * Math.floor(Math.abs(v));\n  }\n\n  return Math.floor(Math.abs(v));\n};\n\nexports.createDataProperty = (o, p, v) => {\n  assert(exports.typeIsObject(o));\n  Object.defineProperty(o, p, { value: v, writable: true, enumerable: true, configurable: true });\n};\n\nexports.createArrayFromList = elements => {\n  // We use arrays to represent lists, so this is basically a no-op.\n  // Do a slice though just in case we happen to depend on the unique-ness.\n  return elements.slice();\n};\n\nexports.ArrayBufferCopy = (dest, destOffset, src, srcOffset, n) => {\n  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n};\n\nexports.CreateIterResultObject = (value, done) => {\n  assert(typeof done === 'boolean');\n  const obj = {};\n  Object.defineProperty(obj, 'value', { value: value, enumerable: true, writable: true, configurable: true });\n  Object.defineProperty(obj, 'done', { value: done, enumerable: true, writable: true, configurable: true });\n  return obj;\n};\n\nexports.IsFiniteNonNegativeNumber = v => {\n  if (Number.isNaN(v)) {\n    return false;\n  }\n  if (v === +Infinity) {\n    return false;\n  }\n  if (v < 0) {\n    return false;\n  }\n\n  return true;\n};\n\nexports.InvokeOrNoop = (O, P, args) => {\n  const method = O[P];\n  if (method === undefined) {\n    return undefined;\n  }\n  return method.apply(O, args);\n};\n\nexports.PromiseInvokeOrNoop = (O, P, args) => {\n  let method;\n  try {\n    method = O[P];\n  } catch (methodE) {\n    return Promise.reject(methodE);\n  }\n\n  if (method === undefined) {\n    return Promise.resolve(undefined);\n  }\n\n  try {\n    return Promise.resolve(method.apply(O, args));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nexports.PromiseInvokeOrFallbackOrNoop = (O, P1, args1, P2, args2) => {\n  let method;\n  try {\n    method = O[P1];\n  } catch (methodE) {\n    return Promise.reject(methodE);\n  }\n\n  if (method === undefined) {\n    return exports.PromiseInvokeOrNoop(O, P2, args2);\n  }\n\n  try {\n    return Promise.resolve(method.apply(O, args1));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\n// Not implemented correctly\nexports.SameRealmTransfer = O => O;\n\nexports.ValidateAndNormalizeHighWaterMark = highWaterMark => {\n  highWaterMark = Number(highWaterMark);\n  if (Number.isNaN(highWaterMark) || highWaterMark < 0) {\n    throw new RangeError('highWaterMark property of a queuing strategy must be nonnegative and non-NaN');\n  }\n\n  return highWaterMark;\n};\n\nexports.ValidateAndNormalizeQueuingStrategy = (size, highWaterMark) => {\n  if (size !== undefined && typeof size !== 'function') {\n    throw new TypeError('size property of a queuing strategy must be a function');\n  }\n\n  highWaterMark = exports.ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n  return { size, highWaterMark };\n};\n",
    "'use strict';\nconst assert = require('assert');\nconst { IsFiniteNonNegativeNumber } = require('./helpers.js');\n\nexports.DequeueValue = queue => {\n  assert(queue.length > 0, 'Spec-level failure: should never dequeue from an empty queue.');\n  const pair = queue.shift();\n  return pair.value;\n};\n\nexports.EnqueueValueWithSize = (queue, value, size) => {\n  size = Number(size);\n  if (!IsFiniteNonNegativeNumber(size)) {\n    throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n  }\n\n  queue.push({ value: value, size: size });\n};\n\nexports.GetTotalQueueSize = queue => {\n  let totalSize = 0;\n\n  queue.forEach(pair => {\n    assert(typeof pair.size === 'number' && !Number.isNaN(pair.size) &&\n      pair.size !== +Infinity && pair.size !== -Infinity,\n      'Spec-level failure: should never find an invalid size in the queue.');\n    totalSize += pair.size;\n  });\n\n  return totalSize;\n};\n\nexports.PeekQueueValue = queue => {\n  assert(queue.length > 0, 'Spec-level failure: should never peek at an empty queue.');\n  const pair = queue[0];\n  return pair.value;\n};\n",
    "'use strict';\nconst assert = require('assert');\nconst { ArrayBufferCopy, CreateIterResultObject, IsFiniteNonNegativeNumber, InvokeOrNoop, PromiseInvokeOrNoop,\n        SameRealmTransfer, ValidateAndNormalizeQueuingStrategy, ValidateAndNormalizeHighWaterMark } =\n      require('./helpers.js');\nconst { createArrayFromList, createDataProperty, typeIsObject } = require('./helpers.js');\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\nconst { DequeueValue, EnqueueValueWithSize, GetTotalQueueSize } = require('./queue-with-sizes.js');\n\nconst InternalCancel = Symbol('[[Cancel]]');\nconst InternalPull = Symbol('[[Pull]]');\n\nclass ReadableStream {\n  constructor(underlyingSource = {}, { size, highWaterMark } = {}) {\n    // Exposed to controllers.\n    this._state = 'readable';\n\n    this._reader = undefined;\n    this._storedError = undefined;\n\n    this._disturbed = false;\n\n    // Initialize to undefined first because the constructor of the controller checks this\n    // variable to validate the caller.\n    this._readableStreamController = undefined;\n    const type = underlyingSource.type;\n    const typeString = String(type);\n    if (typeString === 'bytes') {\n      if (highWaterMark === undefined) {\n        highWaterMark = 0;\n      }\n      this._readableStreamController = new ReadableByteStreamController(this, underlyingSource, highWaterMark);\n    } else if (type === undefined) {\n      if (highWaterMark === undefined) {\n        highWaterMark = 1;\n      }\n      this._readableStreamController = new ReadableStreamDefaultController(this, underlyingSource, size, highWaterMark);\n    } else {\n      throw new RangeError('Invalid type is specified');\n    }\n  }\n\n  get locked() {\n    if (IsReadableStream(this) === false) {\n      throw new TypeError('ReadableStream.prototype.locked can only be used on a ReadableStream');\n    }\n\n    return IsReadableStreamLocked(this);\n  }\n\n  cancel(reason) {\n    if (IsReadableStream(this) === false) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.cancel can only be used on a ReadableStream'));\n    }\n\n    if (IsReadableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('Cannot cancel a stream that already has a reader'));\n    }\n\n    return ReadableStreamCancel(this, reason);\n  }\n\n  getReader({ mode } = {}) {\n    if (IsReadableStream(this) === false) {\n      throw new TypeError('ReadableStream.prototype.getReader can only be used on a ReadableStream');\n    }\n\n    if (mode === 'byob') {\n      if (IsReadableByteStreamController(this._readableStreamController) === false) {\n        throw new TypeError('Cannot get a ReadableStreamBYOBReader for a stream not constructed with a byte source');\n      }\n\n      return AcquireReadableStreamBYOBReader(this);\n    }\n\n    if (mode === undefined) {\n      return AcquireReadableStreamDefaultReader(this);\n    }\n\n    throw new RangeError('Invalid mode is specified');\n  }\n\n  pipeThrough({ writable, readable }, options) {\n    this.pipeTo(writable, options);\n    return readable;\n  }\n\n  pipeTo(dest, { preventClose, preventAbort, preventCancel } = {}) {\n    preventClose = Boolean(preventClose);\n    preventAbort = Boolean(preventAbort);\n    preventCancel = Boolean(preventCancel);\n\n    const source = this;\n\n    let reader;\n    let lastRead;\n    let lastWrite;\n    let closedPurposefully = false;\n    let resolvePipeToPromise;\n    let rejectPipeToPromise;\n\n    return new Promise((resolve, reject) => {\n      resolvePipeToPromise = resolve;\n      rejectPipeToPromise = reject;\n\n      reader = source.getReader();\n\n      reader.closed.catch(abortDest);\n      dest.closed.then(\n        () => {\n          if (!closedPurposefully) {\n            cancelSource(new TypeError('destination is closing or closed and cannot be piped to anymore'));\n          }\n        },\n        cancelSource\n      );\n\n      doPipe();\n    });\n\n    function doPipe() {\n      lastRead = reader.read();\n      Promise.all([lastRead, dest.ready]).then(([{ value, done }]) => {\n        if (Boolean(done) === true) {\n          closeDest();\n        } else if (dest.state === 'writable') {\n          lastWrite = dest.write(value);\n          doPipe();\n        }\n      })\n      .catch(rethrowAssertionErrorRejection);\n\n      // Any failures will be handled by listening to reader.closed and dest.closed above.\n      // TODO: handle malicious dest.write/dest.close?\n    }\n\n    function cancelSource(reason) {\n      if (preventCancel === false) {\n        reader.cancel(reason);\n        reader.releaseLock();\n        rejectPipeToPromise(reason);\n      } else {\n        // If we don't cancel, we need to wait for lastRead to finish before we're allowed to release.\n        // We don't need to handle lastRead failing because that will trigger abortDest which takes care of\n        // both of these.\n        lastRead.then(() => {\n          reader.releaseLock();\n          rejectPipeToPromise(reason);\n        });\n      }\n    }\n\n    function closeDest() {\n      // Does not need to wait for lastRead since it occurs only on source closed.\n\n      reader.releaseLock();\n\n      const destState = dest.state;\n      if (preventClose === false && (destState === 'waiting' || destState === 'writable')) {\n        closedPurposefully = true;\n        dest.close().then(resolvePipeToPromise, rejectPipeToPromise);\n      } else if (lastWrite !== undefined) {\n        lastWrite.then(resolvePipeToPromise, rejectPipeToPromise);\n      } else {\n        resolvePipeToPromise();\n      }\n    }\n\n    function abortDest(reason) {\n      // Does not need to wait for lastRead since it only occurs on source errored.\n\n      reader.releaseLock();\n\n      if (preventAbort === false) {\n        dest.abort(reason);\n      }\n      rejectPipeToPromise(reason);\n    }\n  }\n\n  tee() {\n    if (IsReadableStream(this) === false) {\n      throw new TypeError('ReadableStream.prototype.tee can only be used on a ReadableStream');\n    }\n\n    const branches = ReadableStreamTee(this, false);\n    return createArrayFromList(branches);\n  }\n}\n\nexports.ReadableStream = ReadableStream;\n\n// Abstract operations for the ReadableStream.\n\nfunction AcquireReadableStreamBYOBReader(stream) {\n  return new ReadableStreamBYOBReader(stream);\n}\n\nfunction AcquireReadableStreamDefaultReader(stream) {\n  return new ReadableStreamDefaultReader(stream);\n}\n\nfunction IsReadableStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamDisturbed(stream) {\n  assert(IsReadableStream(stream) === true, 'IsReadableStreamDisturbed should only be used on known readable streams');\n\n  return stream._disturbed;\n}\n\nexports.IsReadableStreamDisturbed = IsReadableStreamDisturbed;\n\nfunction IsReadableStreamLocked(stream) {\n  assert(IsReadableStream(stream) === true, 'IsReadableStreamLocked should only be used on known readable streams');\n\n  if (stream._reader === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamTee(stream, shouldClone) {\n  assert(IsReadableStream(stream) === true);\n  assert(typeof shouldClone === 'boolean');\n\n  const reader = AcquireReadableStreamDefaultReader(stream);\n\n  const teeState = {\n    closedOrErrored: false,\n    canceled1: false,\n    canceled2: false,\n    reason1: undefined,\n    reason2: undefined\n  };\n  teeState.promise = new Promise(resolve => teeState._resolve = resolve);\n\n  const pull = create_ReadableStreamTeePullFunction();\n  pull._reader = reader;\n  pull._teeState = teeState;\n  pull._shouldClone = shouldClone;\n\n  const cancel1 = create_ReadableStreamTeeBranch1CancelFunction();\n  cancel1._stream = stream;\n  cancel1._teeState = teeState;\n\n  const cancel2 = create_ReadableStreamTeeBranch2CancelFunction();\n  cancel2._stream = stream;\n  cancel2._teeState = teeState;\n\n  const underlyingSource1 = Object.create(Object.prototype);\n  createDataProperty(underlyingSource1, 'pull', pull);\n  createDataProperty(underlyingSource1, 'cancel', cancel1);\n  const branch1Stream = new ReadableStream(underlyingSource1);\n\n  const underlyingSource2 = Object.create(Object.prototype);\n  createDataProperty(underlyingSource2, 'pull', pull);\n  createDataProperty(underlyingSource2, 'cancel', cancel2);\n  const branch2Stream = new ReadableStream(underlyingSource2);\n\n  pull._branch1 = branch1Stream._readableStreamController;\n  pull._branch2 = branch2Stream._readableStreamController;\n\n  reader._closedPromise.catch(r => {\n    if (teeState.closedOrErrored === true) {\n      return undefined;\n    }\n\n    ReadableStreamDefaultControllerError(pull._branch1, r);\n    ReadableStreamDefaultControllerError(pull._branch2, r);\n    teeState.closedOrErrored = true;\n  });\n\n  return [branch1Stream, branch2Stream];\n}\n\nfunction create_ReadableStreamTeePullFunction() {\n  const f = () => {\n    const { _reader: reader, _branch1: branch1, _branch2: branch2, _teeState: teeState,\n            _shouldClone: shouldClone } = f;\n\n    return ReadableStreamDefaultReaderRead(reader).then(result => {\n      assert(typeIsObject(result));\n      const value = result.value;\n      const done = result.done;\n      assert(typeof done === \"boolean\");\n\n      if (done === true && teeState.closedOrErrored === false) {\n        if (teeState.canceled1 === false) {\n          ReadableStreamDefaultControllerClose(branch1);\n        }\n        if (teeState.canceled2 === false) {\n          ReadableStreamDefaultControllerClose(branch2);\n        }\n        teeState.closedOrErrored = true;\n      }\n\n      if (teeState.closedOrErrored === true) {\n        return undefined;\n      }\n\n      // There is no way to access the cloning code right now in the reference implementation.\n      // If we add one then we'll need an implementation for StructuredClone.\n\n\n      if (teeState.canceled1 === false) {\n        let value1 = value;\n//        if (shouldClone === true) {\n//          value1 = StructuredClone(value);\n//        }\n        ReadableStreamDefaultControllerEnqueue(branch1, value1);\n      }\n\n      if (teeState.canceled2 === false) {\n        let value2 = value;\n//        if (shouldClone === true) {\n//          value2 = StructuredClone(value);\n//        }\n        ReadableStreamDefaultControllerEnqueue(branch2, value2);\n      }\n    });\n  };\n  return f;\n}\n\nfunction create_ReadableStreamTeeBranch1CancelFunction() {\n  const f = reason => {\n    const { _stream: stream, _teeState: teeState } = f;\n\n    teeState.canceled1 = true;\n    teeState.reason1 = reason;\n    if (teeState.canceled2 === true) {\n      const compositeReason = createArrayFromList([teeState.reason1, teeState.reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      teeState._resolve(cancelResult);\n    }\n    return teeState.promise;\n  };\n  return f;\n}\n\nfunction create_ReadableStreamTeeBranch2CancelFunction() {\n  const f = reason => {\n    const { _stream: stream, _teeState: teeState } = f;\n\n    teeState.canceled2 = true;\n    teeState.reason2 = reason;\n    if (teeState.canceled1 === true) {\n      const compositeReason = createArrayFromList([teeState.reason1, teeState.reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      teeState._resolve(cancelResult);\n    }\n    return teeState.promise;\n  };\n  return f;\n}\n\n// ReadableStream API exposed for controllers.\n\nfunction ReadableStreamAddReadIntoRequest(stream) {\n  assert(IsReadableStreamBYOBReader(stream._reader) === true);\n  assert(stream._state === 'readable' || stream._state === 'closed');\n\n  const promise = new Promise((resolve, reject) => {\n    const readIntoRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._reader._readIntoRequests.push(readIntoRequest);\n  });\n\n  return promise;\n}\n\nfunction ReadableStreamAddReadRequest(stream) {\n  assert(IsReadableStreamDefaultReader(stream._reader) === true);\n  assert(stream._state === 'readable');\n\n  const promise = new Promise((resolve, reject) => {\n    const readRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._reader._readRequests.push(readRequest);\n  });\n\n  return promise;\n}\n\nfunction ReadableStreamCancel(stream, reason) {\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return Promise.resolve(undefined);\n  }\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  ReadableStreamClose(stream);\n\n  const sourceCancelPromise = stream._readableStreamController[InternalCancel](reason);\n  return sourceCancelPromise.then(() => undefined);\n}\n\nfunction ReadableStreamClose(stream) {\n  assert(stream._state === 'readable');\n\n  stream._state = 'closed';\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return undefined;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === true) {\n    for (const { _resolve } of reader._readRequests) {\n      _resolve(CreateIterResultObject(undefined, true));\n    }\n    reader._readRequests = [];\n  }\n\n  reader._closedPromise_resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n\n  return undefined;\n}\n\nfunction ReadableStreamError(stream, e) {\n  assert(IsReadableStream(stream) === true, 'stream must be ReadableStream');\n  assert(stream._state === 'readable', 'state must be readable');\n\n  stream._state = 'errored';\n  stream._storedError = e;\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return undefined;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === true) {\n    for (const readRequest of reader._readRequests) {\n      readRequest._reject(e);\n    }\n\n    reader._readRequests = [];\n  } else {\n    assert(IsReadableStreamBYOBReader(reader), 'reader must be ReadableStreamBYOBReader');\n\n    for (const readIntoRequest of reader._readIntoRequests) {\n      readIntoRequest._reject(e);\n    }\n\n    reader._readIntoRequests = [];\n  }\n\n  reader._closedPromise_reject(e);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n  const reader = stream._reader;\n\n  assert(reader._readIntoRequests.length > 0);\n\n  const readIntoRequest = reader._readIntoRequests.shift();\n  readIntoRequest._resolve(CreateIterResultObject(chunk, done));\n}\n\nfunction ReadableStreamFulfillReadRequest(stream, chunk, done) {\n  const reader = stream._reader;\n\n  assert(reader._readRequests.length > 0);\n\n  const readRequest = reader._readRequests.shift();\n  readRequest._resolve(CreateIterResultObject(chunk, done));\n}\n\nfunction ReadableStreamGetNumReadIntoRequests(stream) {\n  return stream._reader._readIntoRequests.length;\n}\n\nfunction ReadableStreamGetNumReadRequests(stream) {\n  return stream._reader._readRequests.length;\n}\n\nfunction ReadableStreamHasBYOBReader(stream) {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (IsReadableStreamBYOBReader(reader) === false) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamHasDefaultReader(stream) {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === false) {\n    return false;\n  }\n\n  return true;\n}\n\n// Readers\n\nclass ReadableStreamDefaultReader {\n  constructor(stream) {\n    if (IsReadableStream(stream) === false) {\n      throw new TypeError('ReadableStreamDefaultReader can only be constructed with a ReadableStream instance');\n    }\n    if (IsReadableStreamLocked(stream) === true) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readRequests = [];\n  }\n\n  get closed() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(\n        new TypeError('ReadableStreamDefaultReader.prototype.closed can only be used on a ReadableStreamDefaultReader'));\n    }\n\n    return this._closedPromise;\n  }\n\n  cancel(reason) {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(\n        new TypeError('ReadableStreamDefaultReader.prototype.cancel can only be used on a ReadableStreamDefaultReader'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(new TypeError('Cannot cancel a stream using a released reader'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  read() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(\n        new TypeError('ReadableStreamDefaultReader.prototype.read can only be used on a ReadableStreamDefaultReader'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(new TypeError('Cannot read from a released reader'));\n    }\n\n    return ReadableStreamDefaultReaderRead(this);\n  }\n\n  releaseLock() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      throw new TypeError('ReadableStreamDefaultReader.prototype.releaseLock can only be used on a ReadableStreamDefaultReader');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return undefined;\n    }\n\n    if (this._readRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n\nclass ReadableStreamBYOBReader {\n  constructor(stream) {\n    if (!IsReadableStream(stream)) {\n      throw new TypeError('ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a ' +\n          'byte source');\n    }\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readIntoRequests = [];\n  }\n\n  get closed() {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(\n        new TypeError(\n            'ReadableStreamBYOBReader.prototype.closed can only be used on a ReadableStreamBYOBReader'));\n    }\n\n    return this._closedPromise;\n  }\n\n  cancel(reason) {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(\n        new TypeError(\n            'ReadableStreamBYOBReader.prototype.cancel can only be used on a ReadableStreamBYOBReader'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(new TypeError('Cannot cancel a stream using a released reader'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  read(view) {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(\n        new TypeError(\n            'ReadableStreamBYOBReader.prototype.read can only be used on a ReadableStreamBYOBReader'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(new TypeError('Cannot read from a released reader'));\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      return Promise.reject(new TypeError('view must be an array buffer view'));\n    }\n\n    if (view.byteLength === 0) {\n      return Promise.reject(new TypeError('view must have non-zero byteLength'));\n    }\n\n    return ReadableStreamBYOBReaderRead(this, view);\n  }\n\n  releaseLock() {\n    if (!IsReadableStreamBYOBReader(this)) {\n      throw new TypeError(\n          'ReadableStreamBYOBReader.prototype.releaseLock can only be used on a ReadableStreamBYOBReader');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readIntoRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n\n// Abstract operations for the readers.\n\nfunction IsReadableStreamBYOBReader(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamDefaultReader(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamReaderGenericInitialize(reader, stream) {\n  reader._ownerReadableStream = stream;\n  stream._reader = reader;\n\n  if (stream._state === 'readable') {\n    reader._closedPromise = new Promise((resolve, reject) => {\n      reader._closedPromise_resolve = resolve;\n      reader._closedPromise_reject = reject;\n    });\n  } else {\n    if (stream._state === 'closed') {\n      reader._closedPromise = Promise.resolve(undefined);\n      reader._closedPromise_resolve = undefined;\n      reader._closedPromise_reject = undefined;\n    } else {\n      assert(stream._state === 'errored', 'state must be errored');\n\n      reader._closedPromise = Promise.reject(stream._storedError);\n      reader._closedPromise_resolve = undefined;\n      reader._closedPromise_reject = undefined;\n    }\n  }\n}\n\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state check.\n\nfunction ReadableStreamReaderGenericCancel(reader, reason) {\n  const stream = reader._ownerReadableStream;\n  assert(stream !== undefined);\n  return ReadableStreamCancel(stream, reason);\n}\n\nfunction ReadableStreamReaderGenericRelease(reader) {\n  assert(reader._ownerReadableStream !== undefined);\n  assert(reader._ownerReadableStream._reader === reader);\n\n  if (reader._ownerReadableStream._state === 'readable') {\n    reader._closedPromise_reject(\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n  } else {\n    reader._closedPromise = Promise.reject(\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n  }\n\n  reader._ownerReadableStream._reader = undefined;\n  reader._ownerReadableStream = undefined;\n}\n\nfunction ReadableStreamBYOBReaderRead(reader, view) {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  // Controllers must implement this.\n  return ReadableByteStreamControllerPullInto(stream._readableStreamController, view);\n}\n\nfunction ReadableStreamDefaultReaderRead(reader) {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return Promise.resolve(CreateIterResultObject(undefined, true));\n  }\n\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  assert(stream._state === 'readable');\n\n  return stream._readableStreamController[InternalPull]();\n}\n\n// Controllers\n\nclass ReadableStreamDefaultController {\n  constructor(stream, underlyingSource, size, highWaterMark) {\n    if (IsReadableStream(stream) === false) {\n      throw new TypeError('ReadableStreamDefaultController can only be constructed with a ReadableStream instance');\n    }\n\n    if (stream._readableStreamController !== undefined) {\n      throw new TypeError('ReadableStreamDefaultController instances can only be created by the ReadableStream constructor');\n    }\n\n    this._controlledReadableStream = stream;\n\n    this._underlyingSource = underlyingSource;\n\n    this._queue = [];\n    this._started = false;\n    this._closeRequested = false;\n    this._pullAgain = false;\n    this._pulling = false;\n\n    const normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size, highWaterMark);\n    this._strategySize = normalizedStrategy.size;\n    this._strategyHWM = normalizedStrategy.highWaterMark;\n\n    const controller = this;\n\n    const startResult = InvokeOrNoop(underlyingSource, 'start', [this]);\n    Promise.resolve(startResult).then(\n      () => {\n        controller._started = true;\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      },\n      r => {\n        if (stream._state === 'readable') {\n          ReadableStreamDefaultControllerError(controller, r);\n        }\n      }\n    )\n    .catch(rethrowAssertionErrorRejection);\n  }\n\n  get desiredSize() {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw new TypeError(\n        'ReadableStreamDefaultController.prototype.desiredSize can only be used on a ReadableStreamDefaultController');\n    }\n\n    return ReadableStreamDefaultControllerGetDesiredSize(this);\n  }\n\n  close() {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw new TypeError(\n          'ReadableStreamDefaultController.prototype.close can only be used on a ReadableStreamDefaultController');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('The stream has already been closed; do not close it again!');\n    }\n\n    const state = this._controlledReadableStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n    }\n\n    ReadableStreamDefaultControllerClose(this);\n  }\n\n  enqueue(chunk) {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw new TypeError(\n          'ReadableStreamDefaultController.prototype.enqueue can only be used on a ReadableStreamDefaultController');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('stream is closed or draining');\n    }\n\n    const state = this._controlledReadableStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n    }\n\n    return ReadableStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  error(e) {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw new TypeError('ReadableStreamDefaultController.prototype.error can only be used on a ReadableStreamDefaultController');\n    }\n\n    const stream = this._controlledReadableStream;\n    if (stream._state !== 'readable') {\n      throw new TypeError(`The stream is ${stream._state} and so cannot be errored`);\n    }\n\n    ReadableStreamDefaultControllerError(this, e);\n  }\n\n  [InternalCancel](reason) {\n    this._queue = [];\n\n    return PromiseInvokeOrNoop(this._underlyingSource, 'cancel', [reason]);\n  }\n\n  [InternalPull]() {\n    const stream = this._controlledReadableStream;\n\n    if (this._queue.length > 0) {\n      const chunk = DequeueValue(this._queue);\n\n      if (this._closeRequested === true && this._queue.length === 0) {\n        ReadableStreamClose(stream);\n      } else {\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n      }\n\n      return Promise.resolve(CreateIterResultObject(chunk, false));\n    }\n\n    const pendingPromise = ReadableStreamAddReadRequest(stream);\n    ReadableStreamDefaultControllerCallPullIfNeeded(this);\n    return pendingPromise;\n  }\n}\n\n// Abstract operations for the ReadableStreamDefaultController.\n\nfunction IsReadableStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_underlyingSource')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n  const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n  if (shouldPull === false) {\n    return undefined;\n  }\n\n  if (controller._pulling === true) {\n    controller._pullAgain = true;\n    return undefined;\n  }\n\n  controller._pulling = true;\n\n  const pullPromise = PromiseInvokeOrNoop(controller._underlyingSource, 'pull', [controller]);\n  pullPromise.then(\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain === true) {\n        controller._pullAgain = false;\n        return ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      }\n    },\n    e => {\n      if (controller._controlledReadableStream._state === 'readable') {\n        return ReadableStreamDefaultControllerError(controller, e);\n      }\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n\n  return undefined;\n}\n\nfunction ReadableStreamDefaultControllerShouldCallPull(controller) {\n  const stream = controller._controlledReadableStream;\n\n  if (stream._state === 'closed' || stream._state === 'errored') {\n    return false;\n  }\n\n  if (controller._closeRequested === true) {\n    return false;\n  }\n\n  if (controller._started === false) {\n    return false;\n  }\n\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n  if (desiredSize > 0) {\n    return true;\n  }\n\n  return false;\n}\n\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n\nfunction ReadableStreamDefaultControllerClose(controller) {\n  const stream = controller._controlledReadableStream;\n\n  assert(controller._closeRequested === false);\n  assert(stream._state === 'readable');\n\n  controller._closeRequested = true;\n\n  if (controller._queue.length === 0) {\n    ReadableStreamClose(stream);\n  }\n}\n\nfunction ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n  const stream = controller._controlledReadableStream;\n\n  assert(controller._closeRequested === false);\n  assert(stream._state === 'readable');\n\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    ReadableStreamFulfillReadRequest(stream, chunk, false);\n  } else {\n    let chunkSize = 1;\n\n    if (controller._strategySize !== undefined) {\n      try {\n        chunkSize = controller._strategySize(chunk);\n      } catch (chunkSizeE) {\n        if (stream._state === 'readable') {\n          ReadableStreamDefaultControllerError(controller, chunkSizeE);\n        }\n        throw chunkSizeE;\n      }\n    }\n\n    try {\n      EnqueueValueWithSize(controller._queue, chunk, chunkSize);\n    } catch (enqueueE) {\n      if (stream._state === 'readable') {\n        ReadableStreamDefaultControllerError(controller, enqueueE);\n      }\n      throw enqueueE;\n    }\n  }\n\n  ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n\n  return undefined;\n}\n\nfunction ReadableStreamDefaultControllerError(controller, e) {\n  const stream = controller._controlledReadableStream;\n\n  assert(stream._state === 'readable');\n\n  controller._queue = [];\n\n  ReadableStreamError(stream, e);\n}\n\nfunction ReadableStreamDefaultControllerGetDesiredSize(controller) {\n  const queueSize = GetTotalQueueSize(controller._queue);\n  return controller._strategyHWM - queueSize;\n}\n\nclass ReadableStreamBYOBRequest {\n  constructor(controller, view) {\n    this._associatedReadableByteStreamController = controller;\n    this._view = view;\n  }\n\n  get view() {\n    return this._view;\n  }\n\n  respond(bytesWritten) {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw new TypeError(\n          'ReadableByteStreamController.prototype.respond can only be used on a ReadableByteStreamController');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n  }\n\n  respondWithNewView(view) {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw new TypeError(\n          'ReadableByteStreamController.prototype.respond can only be used on a ReadableByteStreamController');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      throw new TypeError('You can only respond with array buffer views');\n    }\n\n    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n  }\n}\n\nclass ReadableByteStreamController {\n  constructor(stream, underlyingByteSource, highWaterMark) {\n    if (IsReadableStream(stream) === false) {\n      throw new TypeError('ReadableByteStreamController can only be constructed with a ReadableStream instance given ' +\n          'a byte source');\n    }\n\n    if (stream._readableStreamController !== undefined) {\n      throw new TypeError(\n          'ReadableByteStreamController instances can only be created by the ReadableStream constructor given a byte ' +\n              'source');\n    }\n\n    this._controlledReadableStream = stream;\n\n    this._underlyingByteSource = underlyingByteSource;\n\n    this._pullAgain = false;\n    this._pulling = false;\n\n    ReadableByteStreamControllerClearPendingPullIntos(this);\n\n    this._queue = [];\n    this._totalQueuedBytes = 0;\n\n    this._closeRequested = false;\n\n    this._started = false;\n\n    this._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n    const autoAllocateChunkSize = underlyingByteSource['autoAllocateChunkSize'];\n    if (autoAllocateChunkSize !== undefined) {\n      if (Number.isInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize < 0) {\n        throw new RangeError(\"autoAllocateChunkSize must be a non negative integer\");\n      }\n    }\n    this._autoAllocateChunkSize = autoAllocateChunkSize;\n\n    this._pendingPullIntos = [];\n\n    const controller = this;\n\n    const startResult = InvokeOrNoop(underlyingByteSource, 'start', [this]);\n    Promise.resolve(startResult).then(\n      () => {\n        controller._started = true;\n\n        assert(controller._pulling === false);\n        assert(controller._pullAgain === false);\n\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      },\n      r => {\n        if (stream._state === 'readable') {\n          ReadableByteStreamControllerError(controller, r);\n        }\n      }\n    )\n    .catch(rethrowAssertionErrorRejection);\n  }\n\n  get byobRequest() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw new TypeError(\n        'ReadableByteStreamController.prototype.byobRequest can only be used on a ReadableByteStreamController');\n    }\n\n    if (this._byobRequest === undefined && this._pendingPullIntos.length > 0) {\n      const firstDescriptor = this._pendingPullIntos[0];\n      const view = new Uint8Array(firstDescriptor.buffer,\n                                  firstDescriptor.byteOffset + firstDescriptor.bytesFilled,\n                                  firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n\n      this._byobRequest = new ReadableStreamBYOBRequest(this, view);\n    }\n\n    return this._byobRequest;\n  }\n\n  get desiredSize() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw new TypeError(\n        'ReadableByteStreamController.prototype.desiredSize can only be used on a ReadableByteStreamController');\n    }\n\n    return ReadableByteStreamControllerGetDesiredSize(this);\n  }\n\n  close() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw new TypeError(\n          'ReadableByteStreamController.prototype.close can only be used on a ReadableByteStreamController');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('The stream has already been closed; do not close it again!');\n    }\n\n    const state = this._controlledReadableStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n    }\n\n    ReadableByteStreamControllerClose(this);\n  }\n\n  enqueue(chunk) {\n    if (IsReadableByteStreamController(this) === false) {\n      throw new TypeError(\n          'ReadableByteStreamController.prototype.enqueue can only be used on a ReadableByteStreamController');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('stream is closed or draining');\n    }\n\n    const state = this._controlledReadableStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n    }\n\n    if (!ArrayBuffer.isView(chunk)) {\n      throw new TypeError('You can only enqueue array buffer views when using a ReadableByteStreamController');\n    }\n\n    ReadableByteStreamControllerEnqueue(this, chunk);\n  }\n\n  error(e) {\n    if (IsReadableByteStreamController(this) === false) {\n      throw new TypeError(\n          'ReadableByteStreamController.prototype.error can only be used on a ReadableByteStreamController');\n    }\n\n    const stream = this._controlledReadableStream;\n    if (stream._state !== 'readable') {\n      throw new TypeError(`The stream is ${stream._state} and so cannot be errored`);\n    }\n\n    ReadableByteStreamControllerError(this, e);\n  }\n\n  [InternalCancel](reason) {\n    if (this._pendingPullIntos.length > 0) {\n      const firstDescriptor = this._pendingPullIntos[0];\n      firstDescriptor.bytesFilled = 0;\n    }\n\n    this._queue = [];\n    this._totalQueuedBytes = 0;\n\n    return PromiseInvokeOrNoop(this._underlyingByteSource, 'cancel', [reason]);\n  }\n\n  [InternalPull]() {\n    const stream = this._controlledReadableStream;\n\n    if (ReadableStreamGetNumReadRequests(stream) === 0) {\n      if (this._totalQueuedBytes > 0) {\n        const entry = this._queue.shift();\n        this._totalQueuedBytes -= entry.byteLength;\n\n        ReadableByteStreamControllerHandleQueueDrain(this);\n\n        let view;\n        try {\n          view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n        } catch (viewE) {\n          return Promise.reject(viewE);\n        }\n\n        return Promise.resolve(CreateIterResultObject(view, false));\n      }\n\n      const autoAllocateChunkSize = this._autoAllocateChunkSize;\n      if (autoAllocateChunkSize !== undefined) {\n        let buffer;\n        try {\n          buffer = new ArrayBuffer(autoAllocateChunkSize);\n        } catch (bufferE) {\n          return Promise.reject(bufferE);\n        }\n\n        const pullIntoDescriptor = {\n          buffer,\n          byteOffset: 0,\n          byteLength: autoAllocateChunkSize,\n          bytesFilled: 0,\n          elementSize: 1,\n          ctor: Uint8Array,\n          readerType: 'default'\n        };\n\n        this._pendingPullIntos.push(pullIntoDescriptor);\n      }\n    } else {\n      assert(this._autoAllocateChunkSize === undefined);\n    }\n\n    const promise = ReadableStreamAddReadRequest(stream);\n\n    ReadableByteStreamControllerCallPullIfNeeded(this);\n\n    return promise;\n  }\n}\n\n// Abstract operations for the ReadableByteStreamController.\n\nfunction IsReadableByteStreamController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_underlyingByteSource')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamBYOBRequest(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller) {\n  const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n  if (shouldPull === false) {\n    return undefined;\n  }\n\n  if (controller._pulling === true) {\n    controller._pullAgain = true;\n    return undefined;\n  }\n\n  controller._pullAgain = false;\n\n  controller._pulling = true;\n\n  // TODO: Test controller argument\n  const pullPromise = PromiseInvokeOrNoop(controller._underlyingByteSource, 'pull', [controller]);\n  pullPromise.then(\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain === true) {\n        controller._pullAgain = false;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      }\n    },\n    e => {\n      if (controller._controlledReadableStream._state === 'readable') {\n        ReadableByteStreamControllerError(controller, e);\n      }\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n\n  return undefined;\n}\n\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  controller._pendingPullIntos = [];\n}\n\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n  assert(stream._state !== 'errored', 'state must not be errored');\n\n  let done = false;\n  if (stream._state === 'closed') {\n    assert(pullIntoDescriptor.bytesFilled === 0);\n    done = true;\n  }\n\n  const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n  if (pullIntoDescriptor.readerType === 'default') {\n    ReadableStreamFulfillReadRequest(stream, filledView, done);\n  } else {\n    assert(pullIntoDescriptor.readerType === 'byob');\n    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n  }\n}\n\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n  const bytesFilled = pullIntoDescriptor.bytesFilled;\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  assert(bytesFilled <= pullIntoDescriptor.byteLength);\n  assert(bytesFilled % elementSize === 0);\n\n  return new pullIntoDescriptor.ctor(\n      pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n}\n\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n  controller._queue.push({buffer, byteOffset, byteLength});\n  controller._totalQueuedBytes += byteLength;\n}\n\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n\n  const maxBytesToCopy = Math.min(controller._totalQueuedBytes,\n                                  pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n  const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n  const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n\n  let totalBytesToCopyRemaining = maxBytesToCopy;\n  let ready = false;\n  if (maxAlignedBytes > currentAlignedBytes) {\n    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n    ready = true;\n  }\n\n  const queue = controller._queue;\n\n  while (totalBytesToCopyRemaining > 0) {\n    const headOfQueue = queue[0];\n\n    const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n\n    const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n\n    if (headOfQueue.byteLength === bytesToCopy) {\n      queue.shift();\n    } else {\n      headOfQueue.byteOffset += bytesToCopy;\n      headOfQueue.byteLength -= bytesToCopy;\n    }\n    controller._totalQueuedBytes -= bytesToCopy;\n\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n\n    totalBytesToCopyRemaining -= bytesToCopy\n  }\n\n  if (ready === false) {\n    assert(controller._totalQueuedBytes === 0, 'queue must be empty');\n    assert(pullIntoDescriptor.bytesFilled > 0);\n    assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize);\n  }\n\n  return ready;\n}\n\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n  assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos[0] === pullIntoDescriptor);\n\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  pullIntoDescriptor.bytesFilled += size;\n}\n\nfunction ReadableByteStreamControllerHandleQueueDrain(controller) {\n  assert(controller._controlledReadableStream._state === 'readable');\n\n  if (controller._totalQueuedBytes === 0 && controller._closeRequested === true) {\n    ReadableStreamClose(controller._controlledReadableStream);\n  } else {\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }\n}\n\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n  if (controller._byobRequest === undefined) {\n    return;\n  }\n\n  controller._byobRequest._associatedReadableByteStreamController = undefined;\n  controller._byobRequest._view = undefined;\n  controller._byobRequest = undefined;\n}\n\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n  assert(controller._closeRequested === false);\n\n  while (controller._pendingPullIntos.length > 0) {\n    if (controller._totalQueuedBytes === 0) {\n      return;\n    }\n\n    const pullIntoDescriptor = controller._pendingPullIntos[0];\n\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n      ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n      ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableStream, pullIntoDescriptor);\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerPullInto(controller, view) {\n  const stream = controller._controlledReadableStream;\n\n  let elementSize = 1;\n  if (view.constructor !== DataView) {\n    elementSize = view.constructor.BYTES_PER_ELEMENT;\n  }\n\n  const ctor = view.constructor;\n\n  const pullIntoDescriptor = {\n    buffer: view.buffer,\n    byteOffset: view.byteOffset,\n    byteLength: view.byteLength,\n    bytesFilled: 0,\n    elementSize,\n    ctor,\n    readerType: 'byob'\n  };\n\n  if (controller._pendingPullIntos.length > 0) {\n    pullIntoDescriptor.buffer = SameRealmTransfer(pullIntoDescriptor.buffer);;\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n\n    // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n    // - No change happens on desiredSize\n    // - The source has already been notified of that there's at least 1 pending read(view)\n\n    return ReadableStreamAddReadIntoRequest(stream);\n  }\n\n  if (stream._state === 'closed') {\n    const emptyView = new view.constructor(view.buffer, view.byteOffset, 0);\n    return Promise.resolve(CreateIterResultObject(emptyView, true));\n  }\n\n  if (controller._totalQueuedBytes > 0) {\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n\n      ReadableByteStreamControllerHandleQueueDrain(controller);\n\n      return Promise.resolve(CreateIterResultObject(filledView, false));\n    }\n\n    if (controller._closeRequested === true) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e)\n\n      return Promise.reject(e);\n    }\n  }\n\n  pullIntoDescriptor.buffer = SameRealmTransfer(pullIntoDescriptor.buffer);\n  controller._pendingPullIntos.push(pullIntoDescriptor);\n\n  const promise = ReadableStreamAddReadIntoRequest(stream);\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n\n  return promise;\n}\n\nfunction ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n  firstDescriptor.buffer = SameRealmTransfer(firstDescriptor.buffer);\n\n  assert(firstDescriptor.bytesFilled === 0, 'bytesFilled must be 0');\n\n  const stream = controller._controlledReadableStream;\n\n  while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n    const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n    ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n  }\n}\n\nfunction ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n  if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {\n    throw new RangeError('bytesWritten out of range');\n  }\n\n  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n\n  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n    // TODO: Figure out whether we should detach the buffer or not here.\n    return;\n  }\n\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n  const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n  if (remainderSize > 0) {\n    const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    const remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n  }\n\n  pullIntoDescriptor.buffer = SameRealmTransfer(pullIntoDescriptor.buffer);\n  pullIntoDescriptor.bytesFilled -= remainderSize;\n  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableStream, pullIntoDescriptor);\n\n  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\n\nfunction ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n  const firstDescriptor = controller._pendingPullIntos[0];\n\n  const stream = controller._controlledReadableStream;\n\n  if (stream._state === 'closed') {\n    if (bytesWritten !== 0) {\n      throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n    }\n\n    ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n  } else {\n    assert(stream._state === 'readable');\n\n    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n  }\n}\n\nfunction ReadableByteStreamControllerShiftPendingPullInto(controller) {\n  const descriptor = controller._pendingPullIntos.shift();\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  return descriptor;\n}\n\nfunction ReadableByteStreamControllerShouldCallPull(controller) {\n  const stream = controller._controlledReadableStream;\n\n  if (stream._state !== 'readable') {\n    return false;\n  }\n\n  if (controller._closeRequested === true) {\n    return false;\n  }\n\n  if (controller._started === false) {\n    return false;\n  }\n\n  if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n    return true;\n  }\n\n  if (ReadableByteStreamControllerGetDesiredSize(controller) > 0) {\n    return true;\n  }\n\n  return false;\n}\n\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\n\nfunction ReadableByteStreamControllerClose(controller) {\n  const stream = controller._controlledReadableStream;\n\n  assert(controller._closeRequested === false);\n  assert(stream._state === 'readable');\n\n  if (controller._totalQueuedBytes > 0) {\n    controller._closeRequested = true;\n\n    return;\n  }\n\n  if (controller._pendingPullIntos.length > 0) {\n    const firstPendingPullInto = controller._pendingPullIntos[0];\n    if (firstPendingPullInto.bytesFilled > 0) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      throw e;\n    }\n  }\n\n  ReadableStreamClose(stream);\n}\n\nfunction ReadableByteStreamControllerEnqueue(controller, chunk) {\n  const stream = controller._controlledReadableStream;\n\n  assert(controller._closeRequested === false);\n  assert(stream._state === 'readable');\n\n  const buffer = chunk.buffer;\n  const byteOffset = chunk.byteOffset;\n  const byteLength = chunk.byteLength;\n  const transferredBuffer = SameRealmTransfer(buffer);\n\n  if (ReadableStreamHasDefaultReader(stream) === true) {\n    if (ReadableStreamGetNumReadRequests(stream) === 0) {\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    } else {\n      assert(controller._queue.length === 0);\n\n      const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n      ReadableStreamFulfillReadRequest(stream, transferredView, false);\n    }\n  } else if (ReadableStreamHasBYOBReader(stream) === true) {\n    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n  } else {\n    assert(IsReadableStreamLocked(stream) === false, 'stream must not be locked');\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n  }\n}\n\nfunction ReadableByteStreamControllerError(controller, e) {\n  const stream = controller._controlledReadableStream;\n\n  assert(stream._state === 'readable');\n\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n\n  controller._queue = [];\n\n  ReadableStreamError(stream, e);\n}\n\nfunction ReadableByteStreamControllerGetDesiredSize(controller) {\n  return controller._strategyHWM - controller._totalQueuedBytes;\n}\n\nfunction ReadableByteStreamControllerRespond(controller, bytesWritten) {\n  bytesWritten = Number(bytesWritten);\n  if (IsFiniteNonNegativeNumber(bytesWritten) === false) {\n    throw new RangeError('bytesWritten must be a finite')\n  }\n\n  assert(controller._pendingPullIntos.length > 0);\n\n  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\n\nfunction ReadableByteStreamControllerRespondWithNewView(controller, view) {\n  assert(controller._pendingPullIntos.length > 0);\n\n  const firstDescriptor = controller._pendingPullIntos[0];\n\n  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n    throw new RangeError('The region specified by view does not match byobRequest');\n  }\n  if (firstDescriptor.byteLength !== view.byteLength) {\n    throw new RangeError('The buffer of view has different capacity than byobRequest');\n  }\n\n  firstDescriptor.buffer = view.buffer;\n\n  ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\n}\n",
    "'use strict';\nconst { ReadableStream } = require('./readable-stream.js');\nconst { WritableStream } = require('./writable-stream.js');\n\nmodule.exports = class TransformStream {\n  constructor(transformer) {\n    if (transformer.flush === undefined) {\n      transformer.flush = (enqueue, close) => close();\n    }\n\n    if (typeof transformer.transform !== 'function') {\n      throw new TypeError('transform must be a function');\n    }\n\n    let writeChunk, writeDone, errorWritable;\n    let transforming = false;\n    let chunkWrittenButNotYetTransformed = false;\n    this.writable = new WritableStream({\n      start(error) {\n        errorWritable = error;\n      },\n      write(chunk) {\n        writeChunk = chunk;\n        chunkWrittenButNotYetTransformed = true;\n\n        const p = new Promise(resolve => writeDone = resolve);\n        maybeDoTransform();\n        return p;\n      },\n      close() {\n        try {\n          transformer.flush(enqueueInReadable, closeReadable);\n        } catch (e) {\n          errorWritable(e);\n          errorReadable(e);\n        }\n      }\n    }, transformer.writableStrategy);\n\n    let enqueueInReadable, closeReadable, errorReadable;\n    this.readable = new ReadableStream({\n      start(c) {\n        enqueueInReadable = c.enqueue.bind(c);\n        closeReadable = c.close.bind(c);\n        errorReadable = c.error.bind(c);\n      },\n      pull() {\n        if (chunkWrittenButNotYetTransformed === true) {\n          maybeDoTransform();\n        }\n      }\n    }, transformer.readableStrategy);\n\n    function maybeDoTransform() {\n      if (transforming === false) {\n        transforming = true;\n        try {\n          transformer.transform(writeChunk, enqueueInReadable, transformDone);\n          writeChunk = undefined;\n          chunkWrittenButNotYetTransformed = false;\n        } catch (e) {\n          transforming = false;\n          errorWritable(e);\n          errorReadable(e);\n        }\n      }\n    }\n\n    function transformDone() {\n      transforming = false;\n      writeDone();\n    }\n  }\n};\n",
    "'use strict';\nconst assert = require('assert');\n\nexports.rethrowAssertionErrorRejection = e => {\n  // Used throughout the reference implementation, as `.catch(rethrowAssertionErrorRejection)`, to ensure any errors\n  // get shown. There are places in the spec where we do promise transformations and purposefully ignore or don't\n  // expect any errors, but assertion errors are always problematic.\n  if (e && e.constructor === assert.AssertionError) {\n    setTimeout(() => {\n      throw e;\n    }, 0);\n  }\n};\n",
    "'use strict';\nconst assert = require('assert');\nconst { InvokeOrNoop, PromiseInvokeOrNoop, PromiseInvokeOrFallbackOrNoop, ValidateAndNormalizeQueuingStrategy,\n        typeIsObject } = require('./helpers.js');\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\nconst { DequeueValue, EnqueueValueWithSize, GetTotalQueueSize, PeekQueueValue } = require('./queue-with-sizes.js');\nconst CountQueuingStrategy = require('./count-queuing-strategy.js');\n\nclass WritableStream {\n  constructor(underlyingSink = {}, { size, highWaterMark = 0 } = {}) {\n    this._underlyingSink = underlyingSink;\n\n    this._closedPromise = new Promise((resolve, reject) => {\n      this._closedPromise_resolve = resolve;\n      this._closedPromise_reject = reject;\n    });\n\n    this._readyPromise = Promise.resolve(undefined);\n    this._readyPromise_resolve = null;\n\n    this._queue = [];\n    this._state = 'writable';\n    this._started = false;\n    this._writing = false;\n\n    const normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size, highWaterMark);\n    this._strategySize = normalizedStrategy.size;\n    this._strategyHWM = normalizedStrategy.highWaterMark;\n\n    SyncWritableStreamStateWithQueue(this);\n\n    const error = closure_WritableStreamErrorFunction();\n    error._stream = this;\n\n    const startResult = InvokeOrNoop(underlyingSink, 'start', [error]);\n    this._startedPromise = Promise.resolve(startResult);\n    this._startedPromise.then(() => {\n      this._started = true;\n      this._startedPromise = undefined;\n    });\n    this._startedPromise.catch(r => ErrorWritableStream(this, r)).catch(rethrowAssertionErrorRejection);\n  }\n\n  get closed() {\n    if (!IsWritableStream(this)) {\n      return Promise.reject(new TypeError('WritableStream.prototype.closed can only be used on a WritableStream'));\n    }\n\n    return this._closedPromise;\n  }\n\n  get state() {\n    if (!IsWritableStream(this)) {\n      throw new TypeError('WritableStream.prototype.state can only be used on a WritableStream');\n    }\n\n    return this._state;\n  }\n\n  abort(reason) {\n    if (!IsWritableStream(this)) {\n      return Promise.reject(new TypeError('WritableStream.prototype.abort can only be used on a WritableStream'));\n    }\n\n    if (this._state === 'closed') {\n      return Promise.resolve(undefined);\n    }\n    if (this._state === 'errored') {\n      return Promise.reject(this._storedError);\n    }\n\n    ErrorWritableStream(this, reason);\n    const sinkAbortPromise = PromiseInvokeOrFallbackOrNoop(this._underlyingSink, 'abort', [reason], 'close', []);\n    return sinkAbortPromise.then(() => undefined);\n  }\n\n  close() {\n    if (!IsWritableStream(this)) {\n      return Promise.reject(new TypeError('WritableStream.prototype.close can only be used on a WritableStream'));\n    }\n\n    if (this._state === 'closing') {\n      return Promise.reject(new TypeError('cannot close an already-closing stream'));\n    }\n    if (this._state === 'closed') {\n      return Promise.reject(new TypeError('cannot close an already-closed stream'));\n    }\n    if (this._state === 'errored') {\n      return Promise.reject(this._storedError);\n    }\n    if (this._state === 'waiting') {\n      this._readyPromise_resolve(undefined);\n    }\n\n    this._state = 'closing';\n    EnqueueValueWithSize(this._queue, 'close', 0);\n    CallOrScheduleWritableStreamAdvanceQueue(this);\n\n    return this._closedPromise;\n  }\n\n  get ready() {\n    if (!IsWritableStream(this)) {\n      return Promise.reject(new TypeError('WritableStream.prototype.ready can only be used on a WritableStream'));\n    }\n\n    return this._readyPromise;\n  }\n\n  write(chunk) {\n    if (!IsWritableStream(this)) {\n      return Promise.reject(new TypeError('WritableStream.prototype.write can only be used on a WritableStream'));\n    }\n\n    if (this._state === 'closing') {\n      return Promise.reject(new TypeError('cannot write while stream is closing'));\n    }\n    if (this._state === 'closed') {\n      return Promise.reject(new TypeError('cannot write after stream is closed'));\n    }\n    if (this._state === 'errored') {\n      return Promise.reject(this._storedError);\n    }\n\n    assert(this._state === 'waiting' || this._state === 'writable');\n\n    let chunkSize = 1;\n\n    if (this._strategySize !== undefined) {\n      try {\n        chunkSize = this._strategySize(chunk);\n      } catch (chunkSizeE) {\n        ErrorWritableStream(this, chunkSizeE);\n        return Promise.reject(chunkSizeE);\n      }\n    }\n\n    let resolver, rejecter;\n    const promise = new Promise((resolve, reject) => {\n      resolver = resolve;\n      rejecter = reject;\n    });\n\n    const writeRecord = { promise: promise, chunk: chunk, _resolve: resolver, _reject: rejecter };\n    try {\n      EnqueueValueWithSize(this._queue, writeRecord, chunkSize);\n    } catch (enqueueResultE) {\n      ErrorWritableStream(this, enqueueResultE);\n      return Promise.reject(enqueueResultE);\n    }\n\n    SyncWritableStreamStateWithQueue(this);\n    CallOrScheduleWritableStreamAdvanceQueue(this);\n    return promise;\n  }\n}\n\nexports.WritableStream = WritableStream;\n\nfunction closure_WritableStreamErrorFunction() {\n  const f = e => ErrorWritableStream(f._stream, e);\n  return f;\n}\n\n\nfunction CallOrScheduleWritableStreamAdvanceQueue(stream) {\n  if (stream._started === false) {\n    stream._startedPromise.then(() => {\n      WritableStreamAdvanceQueue(stream);\n    })\n    .catch(rethrowAssertionErrorRejection);\n    return undefined;\n  }\n\n  if (stream._started === true) {\n    return WritableStreamAdvanceQueue(stream);\n  }\n}\n\nfunction CloseWritableStream(stream) {\n  assert(stream._state === 'closing', 'stream must be in closing state while calling CloseWritableStream');\n\n  const sinkClosePromise = PromiseInvokeOrNoop(stream._underlyingSink, 'close');\n  sinkClosePromise.then(\n    () => {\n      if (stream._state === 'errored') {\n        return;\n      }\n\n      assert(stream._state === 'closing');\n\n      stream._closedPromise_resolve(undefined);\n      stream._closedPromise_resolve = undefined;\n      stream._closedPromise_reject = undefined;\n      stream._state = 'closed';\n    },\n    r => ErrorWritableStream(stream, r)\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction ErrorWritableStream(stream, e) {\n  if (stream._state === 'closed' || stream._state === 'errored') {\n    return undefined;\n  }\n\n  while (stream._queue.length > 0) {\n    const writeRecord = DequeueValue(stream._queue);\n    if (writeRecord !== 'close') {\n      writeRecord._reject(e);\n    }\n  }\n\n  stream._storedError = e;\n\n  if (stream._state === 'waiting') {\n    stream._readyPromise_resolve(undefined);\n  }\n  stream._closedPromise_reject(e);\n  stream._closedPromise_resolve = undefined;\n  stream._closedPromise_reject = undefined;\n  stream._state = 'errored';\n}\n\nfunction IsWritableStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_underlyingSink')) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.IsWritableStream = IsWritableStream;\n\nfunction SyncWritableStreamStateWithQueue(stream) {\n  if (stream._state === 'closing') {\n    return undefined;\n  }\n\n  assert(stream._state === 'writable' || stream._state === 'waiting',\n    'stream must be in a writable or waiting state while calling SyncWritableStreamStateWithQueue');\n\n  const queueSize = GetTotalQueueSize(stream._queue);\n  const shouldApplyBackpressure = queueSize > stream._strategyHWM;\n\n  if (shouldApplyBackpressure === true && stream._state === 'writable') {\n    stream._state = 'waiting';\n    stream._readyPromise = new Promise((resolve, reject) => {\n      stream._readyPromise_resolve = resolve;\n    });\n  }\n\n  if (shouldApplyBackpressure === false && stream._state === 'waiting') {\n    stream._state = 'writable';\n    stream._readyPromise_resolve(undefined);\n  }\n\n  return undefined;\n}\n\nfunction WritableStreamAdvanceQueue(stream) {\n  if (stream._queue.length === 0 || stream._writing === true) {\n    return undefined;\n  }\n\n  const writeRecord = PeekQueueValue(stream._queue);\n\n  if (writeRecord === 'close') {\n    assert(stream._state === 'closing', 'can\\'t process final write record unless already closing');\n    DequeueValue(stream._queue);\n    assert(stream._queue.length === 0, 'queue must be empty once the final write record is dequeued');\n    return CloseWritableStream(stream);\n  } else {\n    stream._writing = true;\n\n    PromiseInvokeOrNoop(stream._underlyingSink, 'write', [writeRecord.chunk]).then(\n      () => {\n        if (stream._state === 'errored') {\n          return;\n        }\n\n        stream._writing = false;\n\n        writeRecord._resolve(undefined);\n\n        DequeueValue(stream._queue);\n        SyncWritableStreamStateWithQueue(stream);\n        WritableStreamAdvanceQueue(stream);\n      },\n      r => ErrorWritableStream(stream, r)\n    )\n    .catch(rethrowAssertionErrorRejection);\n  }\n}\n"
  ]
}